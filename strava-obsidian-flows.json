[
    {
        "id": "strava_obsidian_tab",
        "type": "tab",
        "label": "Strava â†’ Obsidian",
        "disabled": false,
        "info": "Bridges Strava activities with Obsidian daily notes.\n\nFlow 1: Active polling for new activities (every 60 min).\nFlow 2: Historic bulk-loading for a given year (rate-limited to stay within Strava API limits: 100 req/15 min, 1000/day).\nFlow 3: Nightly update of recent activities (replaces existing entries with fresh data).\n\nConfigure the inject nodes with your Strava credentials and vault path."
    },
    {
        "id": "comment_flow1",
        "type": "comment",
        "z": "strava_obsidian_tab",
        "name": "â”€â”€ Flow 1: Active Polling (60 min) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "info": "",
        "x": 280,
        "y": 40,
        "wires": []
    },
    {
        "id": "poll_inject",
        "type": "inject",
        "z": "strava_obsidian_tab",
        "name": "Poll Every 60 min",
        "props": [
            { "p": "clientId", "v": "YOUR_CLIENT_ID", "vt": "str" },
            { "p": "clientSecret", "v": "YOUR_CLIENT_SECRET", "vt": "str" },
            { "p": "refreshToken", "v": "YOUR_REFRESH_TOKEN", "vt": "str" },
            { "p": "vaultPath", "v": "/kms/10 PMS/11 Daily Notes", "vt": "str" },
            { "p": "googleMapsKey", "v": "YOUR_GOOGLE_MAPS_KEY", "vt": "str" }
        ],
        "repeat": "3600",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "x": 150,
        "y": 100,
        "wires": [[ "poll_check_token" ]]
    },
    {
        "id": "poll_check_token",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Check Token",
        "func": "if (!msg.clientId || msg.clientId === 'YOUR_CLIENT_ID') {\n    node.warn('Strava credentials not set. Edit the inject node.');\n    return null;\n}\n\nflow.set('clientId', msg.clientId);\nflow.set('clientSecret', msg.clientSecret);\nflow.set('vaultPath', msg.vaultPath);\nflow.set('googleMapsKey', msg.googleMapsKey);\nflow.set('replaceMode', false);\n\n// Seed persisted refresh token from inject on first run\nconst storedRefresh = flow.get('refreshToken', 'file');\nif (!storedRefresh) {\n    flow.set('refreshToken', msg.refreshToken, 'file');\n}\n\nconst expiresAt = flow.get('expiresAt', 'file') || 0;\nconst now = Math.floor(Date.now() / 1000);\n\nmsg._source = 'poll';\n\nif (now >= expiresAt - 60) {\n    return [null, msg];\n}\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 100,
        "wires": [[ "poll_build_request" ], [ "link_poll_to_refresh" ]],
        "outputLabels": ["valid", "expired"]
    },
    {
        "id": "link_poll_to_refresh",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Token Refresh",
        "mode": "link",
        "links": [ "link_refresh_in" ],
        "x": 515,
        "y": 140,
        "wires": []
    },
    {
        "id": "link_refresh_to_poll",
        "type": "link in",
        "z": "strava_obsidian_tab",
        "name": "â† Refresh (poll)",
        "links": [ "link_refresh_out_poll" ],
        "x": 365,
        "y": 160,
        "wires": [[ "poll_build_request" ]]
    },
    {
        "id": "poll_build_request",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Build API Request",
        "func": "const accessToken = flow.get('accessToken', 'file');\nif (!accessToken) {\n    node.warn('No access token available.');\n    return null;\n}\n\nlet lastTs = flow.get('lastTimestamp', 'file');\nif (!lastTs) {\n    lastTs = Math.floor(Date.now() / 1000) - 86400;\n    flow.set('lastTimestamp', lastTs, 'file');\n}\n\nmsg.url = 'https://www.strava.com/api/v3/athlete/activities'\n    + '?after=' + (lastTs - 86400)\n    + '&per_page=200';\n\nmsg.headers = { 'Authorization': 'Bearer ' + accessToken };\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 550,
        "y": 100,
        "wires": [[ "poll_http" ]]
    },
    {
        "id": "poll_http",
        "type": "http request",
        "z": "strava_obsidian_tab",
        "name": "Strava API",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 730,
        "y": 100,
        "wires": [[ "poll_parse" ]]
    },
    {
        "id": "poll_parse",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Parse & Filter",
        "func": "// Handle rate limit (429)\nif (msg.statusCode === 429) {\n    node.warn('Poll rate limited. Will retry on next poll cycle.');\n    node.status({ fill: 'red', shape: 'ring', text: 'Rate limited' });\n    return null;\n}\n\nconst items = msg.payload;\nif (!Array.isArray(items)) {\n    node.warn('Unexpected API response: ' + JSON.stringify(msg.payload));\n    return null;\n}\n\nif (items.length === 0) {\n    node.log('No new activities found.');\n    return null;\n}\n\nlet maxTs = flow.get('lastTimestamp', 'file') || 0;\nfor (const item of items) {\n    const ts = Math.floor(new Date(item.start_date).getTime() / 1000);\n    if (ts > maxTs) maxTs = ts;\n}\nflow.set('lastTimestamp', maxTs, 'file');\n\nnode.log('Found ' + items.length + ' new activity/activities.');\nnode.status({});\n\nfor (const item of items) {\n    node.send({ payload: item });\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 100,
        "wires": [[ "link_to_format" ]]
    },
    {
        "id": "link_to_format",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Format Chain",
        "mode": "link",
        "links": [ "link_from_flows" ],
        "x": 1055,
        "y": 100,
        "wires": []
    },
    {
        "id": "comment_flow2",
        "type": "comment",
        "z": "strava_obsidian_tab",
        "name": "â”€â”€ Flow 2: Historic Loading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "info": "",
        "x": 290,
        "y": 220,
        "wires": []
    },
    {
        "id": "historic_inject",
        "type": "inject",
        "z": "strava_obsidian_tab",
        "name": "Load History (manual)",
        "props": [
            { "p": "clientId", "v": "YOUR_CLIENT_ID", "vt": "str" },
            { "p": "clientSecret", "v": "YOUR_CLIENT_SECRET", "vt": "str" },
            { "p": "refreshToken", "v": "YOUR_REFRESH_TOKEN", "vt": "str" },
            { "p": "vaultPath", "v": "/kms/10 PMS/11 Daily Notes", "vt": "str" },
            { "p": "googleMapsKey", "v": "YOUR_GOOGLE_MAPS_KEY", "vt": "str" },
            { "p": "historyYear", "v": "2024", "vt": "num" },
            { "p": "replaceMode", "v": "false", "vt": "bool" }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "",
        "topic": "",
        "x": 160,
        "y": 280,
        "wires": [[ "historic_check_token" ]]
    },
    {
        "id": "historic_check_token",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Check Token",
        "func": "if (!msg.clientId || msg.clientId === 'YOUR_CLIENT_ID') {\n    node.warn('Strava credentials not set. Edit the inject node.');\n    return null;\n}\n\nflow.set('clientId', msg.clientId);\nflow.set('clientSecret', msg.clientSecret);\nflow.set('vaultPath', msg.vaultPath);\nflow.set('googleMapsKey', msg.googleMapsKey);\nflow.set('replaceMode', msg.replaceMode);\n\nconst storedRefresh = flow.get('refreshToken', 'file');\nif (!storedRefresh) {\n    flow.set('refreshToken', msg.refreshToken, 'file');\n}\n\nconst expiresAt = flow.get('expiresAt', 'file') || 0;\nconst now = Math.floor(Date.now() / 1000);\n\nmsg._source = 'historic';\n\nif (now >= expiresAt - 60) {\n    return [null, msg];\n}\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 280,
        "wires": [[ "historic_init" ], [ "link_historic_to_refresh" ]],
        "outputLabels": ["valid", "expired"]
    },
    {
        "id": "link_historic_to_refresh",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Token Refresh",
        "mode": "link",
        "links": [ "link_refresh_in" ],
        "x": 535,
        "y": 320,
        "wires": []
    },
    {
        "id": "link_refresh_to_historic",
        "type": "link in",
        "z": "strava_obsidian_tab",
        "name": "â† Refresh (historic)",
        "links": [ "link_refresh_out_historic" ],
        "x": 365,
        "y": 340,
        "wires": [[ "historic_init" ]]
    },
    {
        "id": "historic_init",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Init Pagination",
        "func": "const year = msg.historyYear || new Date().getFullYear();\n\nflow.set('vaultPath', msg.vaultPath);\n\nconst after = Math.floor(Date.UTC(year, 0, 1) / 1000);\nconst before = Math.floor(Date.UTC(year + 1, 0, 1) / 1000);\n\nmsg.after = after;\nmsg.before = before;\nmsg.page = 1;\nmsg.perPage = 200;\nmsg.historyYear = year;\n\nnode.log('Loading activities for year ' + year);\nnode.status({ text: 'Loading year ' + year });\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 280,
        "wires": [[ "historic_build_request" ]]
    },
    {
        "id": "historic_build_request",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Build API Request",
        "func": "const accessToken = flow.get('accessToken', 'file');\nif (!accessToken) {\n    node.warn('No access token available.');\n    return null;\n}\n\nmsg.url = 'https://www.strava.com/api/v3/athlete/activities'\n    + '?after=' + msg.after\n    + '&before=' + msg.before\n    + '&page=' + msg.page\n    + '&per_page=' + msg.perPage;\n\nmsg.headers = { 'Authorization': 'Bearer ' + accessToken };\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 280,
        "wires": [[ "historic_http" ]]
    },
    {
        "id": "historic_http",
        "type": "http request",
        "z": "strava_obsidian_tab",
        "name": "Strava API",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 950,
        "y": 280,
        "wires": [[ "historic_process" ]]
    },
    {
        "id": "historic_process",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Process Page",
        "func": "// Handle rate limit (429)\nif (msg.statusCode === 429) {\n    const retryAfter = (msg.headers && msg.headers['retry-after']) || 120;\n    node.warn('Rate limited on page ' + msg.page + '. Retry after ' + retryAfter + 's');\n    node.status({ fill: 'red', shape: 'ring', text: 'Rate limited page ' + msg.page });\n    // Send back to retry via output 4 (preserves page/pagination state)\n    return [null, null, null, msg];\n}\n\nconst items = msg.payload;\nif (!Array.isArray(items)) {\n    node.warn('Unexpected API response: ' + JSON.stringify(msg.payload));\n    return [null, null, { payload: 'Error at page ' + msg.page }, null];\n}\n\nif (items.length === 0) {\n    node.log('Historic load complete.');\n    return [null, null, { payload: 'Done. No more activities.' }, null];\n}\n\nnode.log('Processing ' + items.length + ' activities at page ' + msg.page);\nnode.status({ text: 'Page ' + msg.page + ', got ' + items.length });\n\nfor (const item of items) {\n    node.send([{ payload: item }, null, null, null]);\n}\n\nif (items.length >= msg.perPage) {\n    const nextMsg = {\n        after: msg.after,\n        before: msg.before,\n        page: msg.page + 1,\n        perPage: msg.perPage,\n        historyYear: msg.historyYear\n    };\n    node.send([null, nextMsg, null, null]);\n} else {\n    node.log('Historic load complete. Last page: ' + items.length + ' activities.');\n    node.send([null, null, { payload: 'Done. All activities loaded for ' + msg.historyYear }, null]);\n}\n\nreturn null;",
        "outputs": 4,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 280,
        "wires": [
            [ "link_historic_to_format" ],
            [ "historic_delay" ],
            [ "historic_status" ],
            [ "historic_retry_delay" ]
        ],
        "outputLabels": [ "activities", "next page", "done/error", "rate limited" ]
    },
    {
        "id": "link_historic_to_format",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Format Chain",
        "mode": "link",
        "links": [ "link_from_flows" ],
        "x": 1275,
        "y": 260,
        "wires": []
    },
    {
        "id": "historic_delay",
        "type": "delay",
        "z": "strava_obsidian_tab",
        "name": "Rate Limit (1s)",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "4",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1140,
        "y": 340,
        "wires": [[ "historic_build_request" ]]
    },
    {
        "id": "historic_status",
        "type": "debug",
        "z": "strava_obsidian_tab",
        "name": "History Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1320,
        "y": 340,
        "wires": []
    },
    {
        "id": "historic_retry_delay",
        "type": "delay",
        "z": "strava_obsidian_tab",
        "name": "429 Retry (2 min)",
        "pauseType": "delay",
        "timeout": "120",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1320,
        "y": 380,
        "wires": [[ "historic_build_request" ]]
    },
    {
        "id": "comment_nightly",
        "type": "comment",
        "z": "strava_obsidian_tab",
        "name": "â”€â”€ Flow 3: Nightly Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "info": "",
        "x": 280,
        "y": 420,
        "wires": []
    },
    {
        "id": "nightly_inject",
        "type": "inject",
        "z": "strava_obsidian_tab",
        "name": "Nightly Update (2 AM)",
        "props": [
            { "p": "clientId", "v": "YOUR_CLIENT_ID", "vt": "str" },
            { "p": "clientSecret", "v": "YOUR_CLIENT_SECRET", "vt": "str" },
            { "p": "refreshToken", "v": "YOUR_REFRESH_TOKEN", "vt": "str" },
            { "p": "vaultPath", "v": "/kms/10 PMS/11 Daily Notes", "vt": "str" },
            { "p": "googleMapsKey", "v": "YOUR_GOOGLE_MAPS_KEY", "vt": "str" },
            { "p": "lookbackDays", "v": "7", "vt": "num" }
        ],
        "repeat": "",
        "crontab": "0 2 * * *",
        "once": false,
        "onceDelay": "",
        "topic": "",
        "x": 160,
        "y": 480,
        "wires": [[ "nightly_check_token" ]]
    },
    {
        "id": "nightly_check_token",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Check Token",
        "func": "if (!msg.clientId || msg.clientId === 'YOUR_CLIENT_ID') {\n    node.warn('Strava credentials not set. Edit the inject node.');\n    return null;\n}\n\nflow.set('clientId', msg.clientId);\nflow.set('clientSecret', msg.clientSecret);\nflow.set('vaultPath', msg.vaultPath);\nflow.set('googleMapsKey', msg.googleMapsKey);\nflow.set('replaceMode', true);\n\nconst storedRefresh = flow.get('refreshToken', 'file');\nif (!storedRefresh) {\n    flow.set('refreshToken', msg.refreshToken, 'file');\n}\n\nconst expiresAt = flow.get('expiresAt', 'file') || 0;\nconst now = Math.floor(Date.now() / 1000);\n\nmsg._source = 'nightly';\nmsg.lookbackDays = msg.lookbackDays || 7;\n\nif (now >= expiresAt - 60) {\n    return [null, msg];\n}\n\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 480,
        "wires": [[ "nightly_init" ], [ "link_nightly_to_refresh" ]],
        "outputLabels": ["valid", "expired"]
    },
    {
        "id": "link_nightly_to_refresh",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Token Refresh",
        "mode": "link",
        "links": [ "link_refresh_in" ],
        "x": 535,
        "y": 520,
        "wires": []
    },
    {
        "id": "link_refresh_to_nightly",
        "type": "link in",
        "z": "strava_obsidian_tab",
        "name": "â† Refresh (nightly)",
        "links": [ "link_refresh_out_nightly" ],
        "x": 365,
        "y": 540,
        "wires": [[ "nightly_init" ]]
    },
    {
        "id": "nightly_init",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Init Pagination",
        "func": "const lookbackDays = msg.lookbackDays || 7;\nconst now = Math.floor(Date.now() / 1000);\nconst after = now - (lookbackDays * 86400);\n\nmsg.after = after;\nmsg.page = 1;\nmsg.perPage = 200;\n\nnode.log('Nightly update: fetching activities from last ' + lookbackDays + ' days');\nnode.status({ text: 'Lookback ' + lookbackDays + ' days' });\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 570,
        "y": 480,
        "wires": [[ "nightly_build_request" ]]
    },
    {
        "id": "nightly_build_request",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Build API Request",
        "func": "const accessToken = flow.get('accessToken', 'file');\nif (!accessToken) {\n    node.warn('No access token available.');\n    return null;\n}\n\nmsg.url = 'https://www.strava.com/api/v3/athlete/activities'\n    + '?after=' + msg.after\n    + '&page=' + msg.page\n    + '&per_page=' + msg.perPage;\n\nmsg.headers = { 'Authorization': 'Bearer ' + accessToken };\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 480,
        "wires": [[ "nightly_http" ]]
    },
    {
        "id": "nightly_http",
        "type": "http request",
        "z": "strava_obsidian_tab",
        "name": "Strava API",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 950,
        "y": 480,
        "wires": [[ "nightly_process" ]]
    },
    {
        "id": "nightly_process",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Process Page",
        "func": "// Handle rate limit (429)\nif (msg.statusCode === 429) {\n    const retryAfter = (msg.headers && msg.headers['retry-after']) || 120;\n    node.warn('Nightly rate limited on page ' + msg.page + '. Retry after ' + retryAfter + 's');\n    node.status({ fill: 'red', shape: 'ring', text: 'Rate limited page ' + msg.page });\n    return [null, null, null, msg];\n}\n\nconst items = msg.payload;\nif (!Array.isArray(items)) {\n    node.warn('Unexpected API response: ' + JSON.stringify(msg.payload));\n    return [null, null, { payload: 'Nightly error at page ' + msg.page }, null];\n}\n\nif (items.length === 0) {\n    node.log('Nightly update complete.');\n    return [null, null, { payload: 'Nightly done. No more activities.' }, null];\n}\n\nnode.log('Nightly processing ' + items.length + ' activities at page ' + msg.page);\nnode.status({ text: 'Page ' + msg.page + ', got ' + items.length });\n\nfor (const item of items) {\n    node.send([{ payload: item }, null, null, null]);\n}\n\nif (items.length >= msg.perPage) {\n    const nextMsg = {\n        after: msg.after,\n        page: msg.page + 1,\n        perPage: msg.perPage\n    };\n    node.send([null, nextMsg, null, null]);\n} else {\n    node.log('Nightly update complete. Last page: ' + items.length + ' activities.');\n    node.send([null, null, { payload: 'Nightly done. All recent activities updated.' }, null]);\n}\n\nreturn null;",
        "outputs": 4,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 480,
        "wires": [
            [ "link_nightly_to_format" ],
            [ "nightly_delay" ],
            [ "nightly_status" ],
            [ "nightly_retry_delay" ]
        ],
        "outputLabels": [ "activities", "next page", "done/error", "rate limited" ]
    },
    {
        "id": "link_nightly_to_format",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Format Chain",
        "mode": "link",
        "links": [ "link_from_flows" ],
        "x": 1275,
        "y": 460,
        "wires": []
    },
    {
        "id": "nightly_delay",
        "type": "delay",
        "z": "strava_obsidian_tab",
        "name": "Rate Limit (1s)",
        "pauseType": "delay",
        "timeout": "1",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "4",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1140,
        "y": 540,
        "wires": [[ "nightly_build_request" ]]
    },
    {
        "id": "nightly_status",
        "type": "debug",
        "z": "strava_obsidian_tab",
        "name": "Nightly Status",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 1320,
        "y": 540,
        "wires": []
    },
    {
        "id": "nightly_retry_delay",
        "type": "delay",
        "z": "strava_obsidian_tab",
        "name": "429 Retry (2 min)",
        "pauseType": "delay",
        "timeout": "120",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1320,
        "y": 580,
        "wires": [[ "nightly_build_request" ]]
    },
    {
        "id": "comment_refresh",
        "type": "comment",
        "z": "strava_obsidian_tab",
        "name": "â”€â”€ Token Refresh Sub-chain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "info": "",
        "x": 290,
        "y": 620,
        "wires": []
    },
    {
        "id": "link_refresh_in",
        "type": "link in",
        "z": "strava_obsidian_tab",
        "name": "â† Needs Refresh",
        "links": [ "link_poll_to_refresh", "link_historic_to_refresh", "link_nightly_to_refresh" ],
        "x": 105,
        "y": 680,
        "wires": [[ "build_refresh_request" ]]
    },
    {
        "id": "build_refresh_request",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Build Refresh Request",
        "func": "const clientId = flow.get('clientId');\nconst clientSecret = flow.get('clientSecret');\nconst refreshToken = flow.get('refreshToken', 'file');\n\nif (!clientId || !clientSecret || !refreshToken) {\n    node.warn('Missing credentials for token refresh.');\n    return null;\n}\n\nmsg.url = 'https://www.strava.com/oauth/token';\nmsg.headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\nmsg.payload = 'client_id=' + clientId\n    + '&client_secret=' + clientSecret\n    + '&refresh_token=' + refreshToken\n    + '&grant_type=refresh_token';\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 680,
        "wires": [[ "refresh_http" ]]
    },
    {
        "id": "refresh_http",
        "type": "http request",
        "z": "strava_obsidian_tab",
        "name": "Strava OAuth",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 510,
        "y": 680,
        "wires": [[ "store_tokens" ]]
    },
    {
        "id": "store_tokens",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Store Tokens",
        "func": "const body = msg.payload;\nif (!body || !body.access_token) {\n    node.warn('Token refresh failed: ' + JSON.stringify(body));\n    return null;\n}\n\nflow.set('accessToken', body.access_token, 'file');\nflow.set('expiresAt', body.expires_at, 'file');\nif (body.refresh_token) {\n    flow.set('refreshToken', body.refresh_token, 'file');\n}\n\nnode.log('Token refreshed. Expires at ' + new Date(body.expires_at * 1000).toISOString());\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 680,
        "wires": [[ "refresh_route" ]]
    },
    {
        "id": "refresh_route",
        "type": "switch",
        "z": "strava_obsidian_tab",
        "name": "Route by _source",
        "property": "_source",
        "propertyType": "msg",
        "rules": [
            { "t": "eq", "v": "poll", "vt": "str" },
            { "t": "eq", "v": "historic", "vt": "str" },
            { "t": "eq", "v": "nightly", "vt": "str" }
        ],
        "checkall": false,
        "repair": false,
        "outputs": 3,
        "x": 870,
        "y": 680,
        "wires": [[ "link_refresh_out_poll" ], [ "link_refresh_out_historic" ], [ "link_refresh_out_nightly" ]],
        "outputLabels": [ "poll", "historic", "nightly" ]
    },
    {
        "id": "link_refresh_out_poll",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Poll (refreshed)",
        "mode": "link",
        "links": [ "link_refresh_to_poll" ],
        "x": 1035,
        "y": 660,
        "wires": []
    },
    {
        "id": "link_refresh_out_historic",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Historic (refreshed)",
        "mode": "link",
        "links": [ "link_refresh_to_historic" ],
        "x": 1035,
        "y": 700,
        "wires": []
    },
    {
        "id": "link_refresh_out_nightly",
        "type": "link out",
        "z": "strava_obsidian_tab",
        "name": "â†’ Nightly (refreshed)",
        "mode": "link",
        "links": [ "link_refresh_to_nightly" ],
        "x": 1035,
        "y": 740,
        "wires": []
    },
    {
        "id": "comment_shared",
        "type": "comment",
        "z": "strava_obsidian_tab",
        "name": "â”€â”€ Shared: Format & Write Chain â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
        "info": "",
        "x": 290,
        "y": 780,
        "wires": []
    },
    {
        "id": "link_from_flows",
        "type": "link in",
        "z": "strava_obsidian_tab",
        "name": "â† From Flows",
        "links": [ "link_to_format", "link_historic_to_format", "link_nightly_to_format" ],
        "x": 105,
        "y": 840,
        "wires": [[ "api_rate_queue" ]]
    },
    {
        "id": "api_rate_queue",
        "type": "delay",
        "z": "strava_obsidian_tab",
        "name": "API Rate (6/min)",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "6",
        "nbRateUnits": "1",
        "rateUnits": "minute",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 170,
        "y": 870,
        "wires": [[ "detail_build_request" ]]
    },
    {
        "id": "detail_build_request",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Build Detail Request",
        "func": "const accessToken = flow.get('accessToken', 'file');\nif (!accessToken) {\n    node.warn('No access token available for detail fetch.');\n    return null;\n}\n\nconst actId = msg.payload && msg.payload.id;\nif (!actId) {\n    node.warn('No activity ID in payload.');\n    return null;\n}\n\nmsg.url = 'https://www.strava.com/api/v3/activities/' + actId;\nmsg.headers = { 'Authorization': 'Bearer ' + accessToken };\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 280,
        "y": 840,
        "wires": [[ "detail_http" ]]
    },
    {
        "id": "detail_http",
        "type": "http request",
        "z": "strava_obsidian_tab",
        "name": "Strava Detail API",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 470,
        "y": 840,
        "wires": [[ "detail_merge" ]]
    },
    {
        "id": "detail_merge",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Merge Detail",
        "func": "// Handle rate limit (429)\nif (msg.statusCode === 429) {\n    const retryAfter = (msg.headers && msg.headers['retry-after']) || 120;\n    node.warn('Rate limited on detail fetch. Retry after ' + retryAfter + 's');\n    node.status({ fill: 'red', shape: 'ring', text: 'Rate limited - retrying' });\n    msg._retryDelay = Number(retryAfter) * 1000;\n    return [null, msg];\n}\n\nif (!msg.payload || !msg.payload.id) {\n    node.warn('Detail fetch failed: ' + JSON.stringify(msg.payload));\n    return null;\n}\n\nnode.status({});\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 640,
        "y": 840,
        "wires": [[ "format_activity" ], [ "detail_retry_delay" ]],
        "outputLabels": [ "ok", "rate limited" ]
    },
    {
        "id": "detail_retry_delay",
        "type": "delay",
        "z": "strava_obsidian_tab",
        "name": "429 Retry (2 min)",
        "pauseType": "delay",
        "timeout": "120",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 640,
        "y": 870,
        "wires": [[ "detail_build_request" ]]
    },
    {
        "id": "format_activity",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Format Activity",
        "func": "const act = msg.payload;\nif (!act || !act.start_date_local) {\n    return null;\n}\n\n// Parse ISO8601 local time\nconst d = new Date(act.start_date_local);\nconst year = d.getFullYear();\nconst month = String(d.getMonth() + 1).padStart(2, '0');\nconst day = String(d.getDate()).padStart(2, '0');\nconst hours = String(d.getHours()).padStart(2, '0');\nconst minutes = String(d.getMinutes()).padStart(2, '0');\n\n// Activity type emoji\nconst emojiMap = {\n    'Run': 'ðŸƒ', 'Ride': 'ðŸš´', 'Swim': 'ðŸŠ',\n    'Hike': 'â›°ï¸', 'Walk': 'ðŸš¶', 'Yoga': 'ðŸ§˜',\n    'WeightTraining': 'ðŸ‹ï¸', 'Workout': 'ðŸ‹ï¸'\n};\nconst type = act.type || 'Workout';\nconst emoji = emojiMap[type] || 'ðŸƒ';\n\n// Distance in km\nconst distKm = act.distance ? (act.distance / 1000).toFixed(2) : null;\n\n// Moving time formatted\nconst totalSec = act.moving_time || 0;\nconst hrs = Math.floor(totalSec / 3600);\nconst mins = Math.floor((totalSec % 3600) / 60);\nconst secs = totalSec % 60;\nlet timeStr;\nif (hrs > 0) {\n    timeStr = hrs + 'h ' + mins + 'm ' + secs + 's';\n} else {\n    timeStr = mins + 'm ' + secs + 's';\n}\n\n// Elapsed time formatted\nconst elapsedSec = act.elapsed_time || 0;\nlet elapsedStr = '';\nif (elapsedSec > 0 && elapsedSec !== totalSec) {\n    const eHrs = Math.floor(elapsedSec / 3600);\n    const eMins = Math.floor((elapsedSec % 3600) / 60);\n    const eSecs = elapsedSec % 60;\n    if (eHrs > 0) {\n        elapsedStr = eHrs + 'h ' + eMins + 'm ' + eSecs + 's';\n    } else {\n        elapsedStr = eMins + 'm ' + eSecs + 's';\n    }\n}\n\n// Elevation\nconst elev = act.total_elevation_gain ? Math.round(act.total_elevation_gain) : null;\n\n// Pace or speed\nlet paceOrSpeed = '';\nconst paceTypes = ['Run', 'Walk', 'Hike'];\nif (distKm && totalSec > 0) {\n    if (paceTypes.includes(type)) {\n        const paceSecPerKm = totalSec / (act.distance / 1000);\n        const paceMin = Math.floor(paceSecPerKm / 60);\n        const paceSec = Math.round(paceSecPerKm % 60);\n        paceOrSpeed = '**Pace:** ' + paceMin + ':' + String(paceSec).padStart(2, '0') + ' /km';\n    } else {\n        const speedKmh = ((act.distance / 1000) / (totalSec / 3600)).toFixed(1);\n        paceOrSpeed = '**Speed:** ' + speedKmh + ' km/h';\n    }\n}\n\n// Heart rate\nlet hrStr = '';\nif (act.average_heartrate) {\n    hrStr = '**Heart Rate:** ' + Math.round(act.average_heartrate);\n    if (act.max_heartrate) {\n        hrStr += ' / ' + Math.round(act.max_heartrate);\n    }\n    hrStr += ' bpm';\n}\n\n// Build lines\nconst lines = [];\nlines.push('- ' + hours + ':' + minutes + ' ' + emoji + ' [' + (act.name || 'Activity') + '](https://www.strava.com/activities/' + act.id + ') : ' + type + ' #strava');\n\n// Description (from detail endpoint)\nif (act.description && act.description.trim().length > 0) {\n    lines.push('\\t- ' + act.description.trim().replace(/\\n/g, ' '));\n}\n\n// Detail line 1: distance, elevation\nconst detail1 = [];\nif (distKm) detail1.push('**Distance:** ' + distKm + ' km');\nif (elev !== null) detail1.push('**Elevation:** ' + elev + ' m');\nif (detail1.length > 0) {\n    lines.push('\\t- ' + detail1.join(' | '));\n}\n\n// Detail line 2: moving time, elapsed time\nconst detail2 = [];\ndetail2.push('**Moving Time:** ' + timeStr);\nif (elapsedStr) detail2.push('**Elapsed Time:** ' + elapsedStr);\nif (detail2.length > 0) {\n    lines.push('\\t- ' + detail2.join(' | '));\n}\n\n// Detail line 3: pace/speed, heart rate\nconst detail3 = [];\nif (paceOrSpeed) detail3.push(paceOrSpeed);\nif (hrStr) detail3.push(hrStr);\nif (detail3.length > 0) {\n    lines.push('\\t- ' + detail3.join(' | '));\n}\n\n// Detail line 4: kudos, comments (only non-zero values, omit line if all zero)\nconst detail4 = [];\nif (act.kudos_count) detail4.push('**Kudos:** ' + act.kudos_count);\nif (act.comment_count) detail4.push('**Comments:** ' + act.comment_count);\nif (detail4.length > 0) {\n    lines.push('\\t- ' + detail4.join(' | '));\n}\n\n// Map: static image if Google Maps key configured, otherwise OSM link\nconst googleMapsKey = flow.get('googleMapsKey');\nconst polyline = act.map && act.map.summary_polyline;\nif (polyline && googleMapsKey && googleMapsKey !== 'YOUR_GOOGLE_MAPS_KEY') {\n    const encodedPolyline = encodeURIComponent(polyline);\n    lines.push('\\t- ![Map](https://maps.googleapis.com/maps/api/staticmap?size=600x300&path=weight:3%7Ccolor:red%7Cenc:' + encodedPolyline + '&key=' + googleMapsKey + ')');\n} else if (act.start_latlng && act.start_latlng.length === 2) {\n    const lat = act.start_latlng[0].toFixed(4);\n    const lng = act.start_latlng[1].toFixed(4);\n    lines.push('\\t- [Map](https://www.openstreetmap.org/?mlat=' + lat + '&mlon=' + lng + '#map=15/' + lat + '/' + lng + ')');\n}\n\nmsg.noteupdate = lines.join('\\n');\nmsg.activityId = String(act.id);\nmsg.payload = Date.now();\n\nmsg.dateStr = { year: String(year), month, day };\nmsg.files = { dailynotefile: year + '-' + month + '-' + day + '.md' };\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 840,
        "wires": [[ "build_filename" ]]
    },
    {
        "id": "build_filename",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Daily Note Filename",
        "func": "const vaultPath = flow.get('vaultPath') || '/kms/10 PMS/11 Daily Notes';\n\nmsg.filename = vaultPath\n    + '/' + msg.dateStr.year\n    + '/' + msg.dateStr.month\n    + '/' + msg.files.dailynotefile;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 840,
        "wires": [[ "write_queue" ]]
    },
    {
        "id": "write_queue",
        "type": "delay",
        "z": "strava_obsidian_tab",
        "name": "Queue (1/s)",
        "pauseType": "rate",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1180,
        "y": 840,
        "wires": [[ "file_read" ]]
    },
    {
        "id": "file_read",
        "type": "file in",
        "z": "strava_obsidian_tab",
        "name": "Read Daily Note",
        "filename": "filename",
        "filenameType": "msg",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "utf8",
        "allProps": true,
        "x": 280,
        "y": 900,
        "wires": [[ "insert_into_notes" ]]
    },
    {
        "id": "insert_into_notes",
        "type": "function",
        "z": "strava_obsidian_tab",
        "name": "Insert into ## Notes",
        "func": "const activity = msg.noteupdate;\nlet content = '';\n\nif (typeof msg.payload === 'string' && msg.payload.length > 0) {\n    content = msg.payload;\n} else {\n    content = '';\n}\n\nconst replaceMode = flow.get('replaceMode') || false;\n\n// Check if this activity ID already exists in the file\nif (msg.activityId && content.indexOf(msg.activityId) !== -1) {\n    if (!replaceMode) {\n        node.log('Activity ' + msg.activityId + ' already exists, skipping.');\n        return null;\n    }\n    // Replace mode: find full entry block and replace\n    const lines = content.split('\\n');\n    let startIdx = -1;\n    let endIdx = -1;\n    for (let i = 0; i < lines.length; i++) {\n        if (lines[i].indexOf('strava.com/activities/' + msg.activityId) !== -1) {\n            startIdx = i;\n            endIdx = i + 1;\n            // Consume all tab-indented sub-items\n            while (endIdx < lines.length && lines[endIdx].startsWith('\\t')) {\n                endIdx++;\n            }\n            break;\n        }\n    }\n    if (startIdx !== -1) {\n        lines.splice(startIdx, endIdx - startIdx, ...activity.split('\\n'));\n        msg.payload = lines.join('\\n');\n        node.log('Replaced activity ' + msg.activityId);\n        return msg;\n    }\n}\n\nconst notesHeading = '## Notes';\nconst notesIdx = content.indexOf(notesHeading);\n\nif (notesIdx !== -1) {\n    const afterNotes = content.substring(notesIdx + notesHeading.length);\n    const nextHeadingMatch = afterNotes.match(/\\n## [^#]/);\n    \n    if (nextHeadingMatch) {\n        const insertPos = notesIdx + notesHeading.length + nextHeadingMatch.index;\n        msg.payload = content.substring(0, insertPos) + '\\n' + activity + content.substring(insertPos);\n    } else {\n        msg.payload = content.trimEnd() + '\\n' + activity + '\\n';\n    }\n} else {\n    msg.payload = content.trimEnd() + '\\n\\n## Notes\\n' + activity + '\\n';\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 900,
        "wires": [[ "file_write" ]]
    },
    {
        "id": "file_write",
        "type": "file",
        "z": "strava_obsidian_tab",
        "name": "Write Daily Note",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": true,
        "overwriteFile": true,
        "encoding": "none",
        "x": 660,
        "y": 900,
        "wires": [[ "write_debug" ]]
    },
    {
        "id": "write_debug",
        "type": "debug",
        "z": "strava_obsidian_tab",
        "name": "Write Complete",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "filename",
        "targetType": "msg",
        "statusVal": "filename",
        "statusType": "auto",
        "x": 850,
        "y": 900,
        "wires": []
    }
]
